# 美团面试题（一面）20230919

## Redis 线程模型

### 解释单线程与多线程

> redis 单线程是指处理命令的时候事单线程的。但是redis其它部分，比如说持久化其实就是多线程的在处理。redis 是多线程的特别是在 6.0 之后，连io模型都改成了多线程的模型，进一步发挥的多核cpu的优势。

> redis 高性能有两方面的原因，一方面 redis 处理命令的时候，都是纯内存操作。另一方面，在liunx 系统上redis 采用了 epoll 和 Reactor 模型 IO模型非常高效。

###  什么事 epoll ，Reactor 模型

####  epoll

> 在linux操作系统中，套接字就是一个普通的文件描述符号，因此 epoll 本质上是管理者一堆文件描述符。

#### epoll 的基本结构和系统调用

> 一个红黑树，每一个节点代表一个文件描述符。另外一个是双向链表，也叫做就行队列。
> 三个关键的系统调用：1.epoll_create  2.epoll_ctl. 3.epoll_wait

####  epoll  的调用流程

1. 调用 epoll wait 
2. 检查就行队列。有数据直接返回。
3. 就行队列中不存数据，根据超时时间设置会有不同的响应 -1 永远阻塞，0 立即返回，n 等待直到超时。
4. epoll 结合系统中断检测数据及超时。

#### Reactor

> Reactor 模式也是广泛应用的 io 模式，他的性能好。一个分发器 + 一堆处理器。

> 客户端与服务器的 io 交换主要有两类事件：连接事件，读写事件。Reactor 里的分发器会把连接事件交给Acceptor，把读写事件交给对应的 handler。

Redis 的 Reactor 就是调用了 epoll，拿到创建连接套件字的连接，或者读写的套件字 转发给 acceptor 或 handler 

#### Reactor 变种

> 把 Accetor 做成多线程。把 Handler 做成多线程。把 Reactor 做成多线程。

### Redis 的多线程模型

> Redis 在6之后引入了多线程，在搞并发场景下利用多线程并发处理 io 任务，命令解析和数据回写。这些线程也叫做io线程。

在多线程模式，可看着是 单线程Reactor，单线程 Accetor，多线程 Handler

#### 交互流程

1. 客户端发起请求的时候，主程序会收到一个可读的事件，于是把它对应的客户端丢到可读客户端列表。
2. 一个 io 线程会被安排读这个客户端发来的命令，并且解析号。
3. 主线程执行 io 线程解析好的命令，并把响应写回到可写客户端列表。
4. io 线程复杂写响应。流程结束。


## Mysql  与 Redis

### 预备知识点
####  二叉树

> 二叉树是一种特殊的树状数据结构，它由节点组成，每个节点最多有两个子节点，分别称为左子节点和右子节点。这两个子节点通常被称为左子树和右子树。

#### 二叉搜索树

> 一种特殊的二叉树，其中左子树的所有节点的值小于根节点的值，右子树的所有节点的值大于根节点的值。

#### 满二叉树树

> 除了叶节点，每个节点都有两个子节点。

#### 完全二叉树

> 除了最后一层，其他层的节点都是满的，最后一层的节点尽可能靠左排列。

#### 平衡二叉树

> 平衡二叉树（Balanced Binary Tree）是一种特殊的二叉搜索树（BST），它的左子树和右子树的高度差不超过1，也就是说，任何节点的两棵子树的高度差不能超过1。

1.  **AVL树**：由G.M. Adelson-Velsky和E.M. Landis在1962年提出，是一种最早的自平衡二叉搜索树。在AVL树中，任何节点的两个子树的高度最多相差1。
    
2.  **红黑树**：由鲁道夫·贝尔在1972年提出，是一种相对较新的自平衡二叉搜索树。它通过对树的节点着色和旋转等操作来保持树的平衡。
    
3.  **Splay树**：虽然不是严格的平衡树，但它在许多实际应用中表现出色。Splay树通过频繁访问的节点上升到靠近根节点的位置，从而提高了这些节点的访问速度。
    
4.  **Treap**：同时使用随机性和二叉搜索树的性质，它是一种基于优先级的平衡二叉搜索树。
    
5.  **AA树**：一种比较简单的自平衡二叉搜索树，由Arne Andersson在1993年提出。
    
6.  **伸展树（Scapegoat Tree）**：是一种自平衡二叉搜索树，它通过旋转和重建操作来保持平衡。





编码---合并区间


### 为什么 Redis 用跳表实现而 MySQL 用 B+ 树实现

#### 什么是跳表

> 跳表本身基于链表，是对链表的优化。
> 跳表事只能在链表元素中有序的情况下使用的数据结构，既跳表中的元素必须有序其插入，删除，搜索的时间复杂度为 $O(log_2^n)$.

####  B 与 B+ 树

> B树（B-tree）是一种多叉树（或称平衡搜索树）数据结构，广泛用于数据库和文件系统等需要高效地插入、删除和查找的场景。B+树（B+ tree）是B树的一种变种，也是一种常用于数据库和文件系统的数据结构。

 ##### 主要区别：
 
 1. 内部结点的存储方式.
       > 在B树中，内部节点既包含关键字也包含指向子节点的指针。
       > 在B+树中，内部节点只包含关键字，而指向子节点的指针都存储在叶子节点中。
2. 叶子节点的结构。
      > 在B树中，叶子节点包含了实际的数据，以及指向子节点的指针。
      > 在B+树中，叶子节点只包含实际的数据，而且它们之间通过指针连接成一个有序链表。
      
3. 区别导致的特性。
     > 围查询和顺序访问：由于B+树的叶子节点形成了一个有序链表，因此在B+树上进行范围查询和顺序访问非常高效。
      > 适合用于数据库索引：由于B+树的内部节点只包含关键字，可以存储更多的索引信息，使得B+树更适合用于数据库的索引实现。
      > 维护平衡：B+树的平衡调整只需要在叶子节点进行，而B树需要在所有节点进行。这使得B+树的平衡调整开销更小。
     >  数据的存储和查询：在B+树中，实际数据只存储在叶子节点中，因此对于范围查询等操作，通常需要遍历叶子节点链表。
     
 #### 对比
 
 B+ 树一般都是叶子满了且索引节点也满了才会增加 B+ 树的高度，MySQL 中的 B+ 树一般三层高就能够保存 2100 多万条记录。对于数据查询，即便这些要查询的数据保存在磁盘中，那么也只需要进行 3 次磁盘 IO 操作就可以拿到数据。
 
 向跳表中增加数据时，跳表的高度是否增加是靠随机值——一个新数据插入到原始链表后，有 50% 的概率在第二层索引中加入该数据，有 25% 的概率在第三层索引中加入该数据，以此类推，直到最顶层索引。对于数据查询，如果要在原始链表中存储 2100 多万条记录（224），跳表的高度大概要达到 24 层，这意味着查询一次数据，如果运气比较坏可能要进行 24 次磁盘 IO 操作才可以拿到数据。和 B+ 树比，跳表的查询效率显然慢很多。
 
 对于写操作，跳表的插入操作和 B+ 树相比要简单很多，所以跳表的写入方面性能要优于 B+ 树。
 
 
 #### Redis 为什么用跳表实现有序集合而不是用红黑树 /B+ 树 / 二叉树实现？
 
 对于数据的插入、删除、查询等操作：
 
 二叉树（包括 AVL 树、红黑树）需要对节点调整平衡（旋转、变色操作）。
 
 B+ 树存在一系列节点的拆分、合并操作。
 
 跳表插入和删除数据时不需要考虑平衡性，也不需要拆分合并等。
 
 另外，对于按照某个区间查找数据这个操作，AVL 树、红黑树的效率没有跳表高。因为跳表能以 O(log2n​) 的时间复杂度定位到区间的起点，然后在原始链表中顺序向后遍历即可。
 
## 编码合并区间
 
 ```java
class   Solution {

 public   int\[\]\[\] merge(int\[\]\[\] intervals) {

 //边界值判断
 if (intervals.length == 0) {

 return   new   int\[0\]\[2\];

}

 //排序集合 start 从小到达

 Arrays.sort(intervals, new   Comparator<int\[\]>() {

 public   int   compare(int\[\] interval1, int\[\] interval2) {

 return interval1\[0\] \- interval2\[0\];

}

});

 //返回集合初始化

 List<int\[\]\> merged = new   ArrayList<int\[\]>();

 //遍历集合并合并

 for (int   i = 0; i < intervals.length; ++i) {

 //获取开闭 start end 值

 int   L = intervals\[i\]\[0\], R = intervals\[i\]\[1\];

 //新值与合并的值比较，已有值在新值的范围内

 if (merged.size() == 0 || merged.get(merged.size() \- 1)\[1\] < L) {

 merged.add(new   int\[\]{L, R});

} else {

 //更新已有值的R值（end值）

 merged.get(merged.size() \- 1)\[1\] = Math.max(merged.get(merged.size() \- 1)\[1\], R);

}

}

 return   merged.toArray(new   int\[merged.size()\]\[\]);

}

}
```
